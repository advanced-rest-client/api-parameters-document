<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-parameters-document test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>
  <script src="../../../sinon/pkg/sinon.js"></script>

  <script src="./amf-loader.js"></script>
  <script type="module" src="../api-parameters-document.js"></script>
  <custom-style>
    <style is="custom-style">
    :root {
      --api-parameters-document-title-narrow: {
        font-weight: 200;
        font-size: 16px;
      };
    }
    </style>
  </custom-style>
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <api-parameters-document></api-parameters-document>
    </template>
  </test-fixture>

  <test-fixture id="Narrow">
    <template>
      <api-parameters-document narrow></api-parameters-document>
    </template>
  </test-fixture>

  <script type="module">
  /* global AmfLoader */
  function getEncodes(model, compact) {
    if (model instanceof Array) {
      model = model[0];
    }
    const encKey = compact ? 'doc:encodes' : 'http://a.ml/vocabularies/document#encodes';
    let def = model[encKey];
    if (def instanceof Array) {
      def = def[0];
    }
    return def;
  }

  function getServer(enc, compact) {
    const key = compact ? 'raml-http:server' : 'http://a.ml/vocabularies/http#server';
    let def = enc[key];
    if (def instanceof Array) {
      def = def[0];
    }
    return def;
  }

  function getSrvBaseVariables(srv, compact) {
    const key = compact ? 'raml-http:variable' : 'http://a.ml/vocabularies/http#variable';
    let def = srv[key];
    if (!(def instanceof Array)) {
      def = [def];
    }
    return def;
  }

  function getMethod(model, compact, endpointIndex, methodIndex) {
    const enc = getEncodes(model, compact);
    const key = compact ? 'raml-http:endpoint' : 'http://a.ml/vocabularies/http#endpoint';
    let endpoints = enc[key];
    if (!(endpoints instanceof Array)) {
      endpoints = [endpoints];
    }
    const endpoint = endpoints[endpointIndex];
    const mkey = compact ? 'hydra:supportedOperation' : 'http://www.w3.org/ns/hydra/core#supportedOperation';
    let methods = endpoint[mkey];
    if (!(methods instanceof Array)) {
      methods = [methods];
    }
    let method = methods[methodIndex];
    if (method instanceof Array) {
      method = method[0];
    }
    return method;
  }

  function getExpects(method, compact) {
    const key = compact ? 'hydra:expects' : 'http://www.w3.org/ns/hydra/core#expects';
    let result = method[key];
    if (result instanceof Array) {
      result = result[0];
    }
    return result;
  }

  function computeServerVariables(model, compact) {
    const enc = getEncodes(model, compact);
    const srv = getServer(enc, compact);
    return getSrvBaseVariables(srv, compact);
  }

  function computePathParameters(model, compact, endpointIndex, methodIndex) {
    const method = getMethod(model, compact, endpointIndex, methodIndex);
    const key = compact ? 'raml-http:parameter' : 'http://a.ml/vocabularies/http#endpoint';
    let params = method[key];
    if (!(params instanceof Array)) {
      params = [params];
    }
    return params;
  }

  function computeQueryParameters(model, compact, endpointIndex, methodIndex) {
    const method = getMethod(model, compact, endpointIndex, methodIndex);
    const expect = getExpects(method, compact);
    const key = compact ? 'raml-http:parameter' : 'http://a.ml/vocabularies/http#parameter';
    let params = expect[key];
    if (!(params instanceof Array)) {
      params = [params];
    }
    return params;
  }

  suite('Basic', () => {
    let element;

    setup(() => {
      element = fixture('Basic');
    });

    test('Renders no params tables without data', (done) => {
      flush(() => {
        const doc = element.shadowRoot.querySelector('api-type-document');
        assert.notOk(doc);
        done();
      });
    });

    test('hasQueryParameters is undefined', () => {
      assert.isUndefined(element.hasQueryParameters);
    });

    test('hasPathParameters is undefined', () => {
      assert.isUndefined(element.hasPathParameters);
    });
  });

  suite('Base path parameters', () => {
    [
      ['Full model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        setup((done) => {
          AmfLoader.load(item[1])
          .then((amf) => {
            element = fixture('Basic');
            element.amfModel = amf;
            element.baseUriParameters = computeServerVariables(amf, item[1]);
            flush(() => done());
          });
        });

        test('Computes _effectivePathParameters', () => {
          assert.typeOf(element._effectivePathParameters, 'array');
          assert.lengthOf(element._effectivePathParameters, 2);
        });

        test('Computes hasPathParameters', () => {
          assert.isTrue(element.hasPathParameters);
        });

        test('Renders uri parameters table', () => {
          const section = element.shadowRoot.querySelector('.uri-parameters');
          assert.ok(section);
        });

        test('Parameters are set on table', () => {
          const doc = element.shadowRoot.querySelector('.uri-parameters api-type-document');
          assert.isTrue(doc.type === element._effectivePathParameters);
        });

        test('Toggle button open the URI section', () => {
          const button = element.shadowRoot.querySelector('.uri-parameters .section-title-area');
          button.click();
          assert.isTrue(element.pathOpened);
        });
      });
    });
  });

  suite('Base path + endpoint path parameters', () => {
    [
      ['Full model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        setup((done) => {
          AmfLoader.load(item[1])
          .then((amf) => {
            element = fixture('Basic');
            element.amfModel = amf;
            element.baseUriParameters = computeServerVariables(amf, item[1]);
            element.endpointParameters = computePathParameters(amf, item[1], 0, 0);
            flush(() => done());
          });
        });

        test('Computes _effectivePathParameters', () => {
          assert.typeOf(element._effectivePathParameters, 'array');
        });

        test('_effectivePathParameters contains both parameters arrays', () => {
          assert.lengthOf(element._effectivePathParameters, 3);
        });

        test('Computes hasPathParameters', () => {
          assert.isTrue(element.hasPathParameters);
        });

        test('Renders uri parameters table', () => {
          const section = element.shadowRoot.querySelector('.uri-parameters');
          assert.ok(section);
        });

        test('Query table is not', () => {
          const doc = element.shadowRoot.querySelector('.uri-parameters api-type-document');
          assert.isTrue(doc.type === element._effectivePathParameters);
        });
      });
    });
  });

  suite('Base path + endpoint path parameters', () => {
    [
      ['Full model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        setup((done) => {
          AmfLoader.load(item[1])
          .then((amf) => {
            element = fixture('Basic');
            element.amfModel = amf;
            element.baseUriParameters = computeServerVariables(amf, item[1]);
            element.endpointParameters = computePathParameters(amf, item[1], 2, 0);
            element.queryParameters = computeQueryParameters(amf, item[1], 2, 0);
            flush(() => done());
          });
        });

        test('Computes hasQueryParameters', () => {
          assert.isTrue(element.hasQueryParameters);
        });

        test('Renders query parameters table', () => {
          const section = element.shadowRoot.querySelector('.query-parameters');
          assert.ok(section);
        });

        test('Parameters are set on table', () => {
          const doc = element.shadowRoot.querySelector('.query-parameters api-type-document');
          assert.isTrue(doc.type === element.queryParameters);
        });

        test('Toggle button open the Query section', () => {
          const button = element.shadowRoot.querySelector('.query-parameters .section-title-area');
          button.click();
          assert.isTrue(element.queryOpened);
        });
      });
    });
  });

  suite('Narrow layout', () => {
    [
      ['Full model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        setup((done) => {
          AmfLoader.load(item[1])
          .then((amf) => {
            element = fixture('Narrow');
            element.amfModel = amf;
            element.baseUriParameters = computeServerVariables(amf, item[1]);
            element.endpointParameters = computePathParameters(amf, item[1], 2, 0);
            element.queryParameters = computeQueryParameters(amf, item[1], 2, 0);
            flush(() => done());
          });
        });

        test('Has narrow attribute', () => {
          assert.isTrue(element.hasAttribute('narrow'));
        });

        test('Narrow style is applied to the URI title', () => {
          const title = element.shadowRoot.querySelector('.uri-parameters .table-title');
          const fontWeight = getComputedStyle(title).fontWeight;
          const fontSize = getComputedStyle(title).fontSize;
          assert.equal(fontWeight, '200');
          assert.equal(fontSize, '16px');
        });

        test('Narrow style is applied to the Query title', () => {
          const title = element.shadowRoot.querySelector('.query-parameters .table-title');
          const fontWeight = getComputedStyle(title).fontWeight;
          const fontSize = getComputedStyle(title).fontSize;
          assert.equal(fontWeight, '200');
          assert.equal(fontSize, '16px');
        });
      });
    });
  });
  </script>
</body>
</html>
